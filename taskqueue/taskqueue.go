// A simple taskmanager that operates on a channel
package taskqueue

import (
    "bitbucket.com/andrews2000/multicam/recordcontrol"
    "log"
)

type TaskQueue struct {
    Queue chan Task
}

// Execute tasks until stopping channel is true
func (tq TaskQueue) ExecuteTask(rc *recordcontrol.RecordControl) {
    for {
        cmd := <-tq.Queue
        cmdType := cmd.Command

        log.Printf("INFO: Executing task on taskqueue: %s",cmdType)

        switch cmdType  {
        case "GetStatus":
            cmd.FeedbackChannel <- rc.TaskGetStatus()
        case "GetConfig":
            cmd.FeedbackChannel <- rc.TaskGetConfig()
        case "SetConfig":
            data := cmd.Data.(map[string]interface{})

            cams_cfg := data["Cameras"].([]interface{})
            cams := make([]int, len(cams_cfg))
            for i,cam := range cams_cfg {
                cams[i] = int(cam.(float64))
            }

            mics_cfg := data["Microphones"].([]interface{})
            mics := make([]int, len(mics_cfg))
            for i,mic := range mics_cfg {
                mics[i] = int(mic.(float64))
            }

            recConfig := recordcontrol.RecordConfig{Cameras: cams, Microphones: mics, Sid: data["Sid"].(string), RecFolder: data["RecFolder"].(string)}
            cmd.FeedbackChannel <- rc.TaskSetConfig(recConfig)
        case "StartRecording":
            cmd.FeedbackChannel <- rc.TaskStartRecording()
        case "StopRecording":
            cmd.FeedbackChannel <- rc.TaskStopRecording()
        case "Error":
            //TODO run error handling function of task queue
        case "ReturnError":
            cmd.FeedbackChannel <- []byte("")
        default:
            //TODO Some sort of error handling
        }
    }
}

// A command generated by one of the servers
type Task struct {
    // The type of the command
    Command string
    // The "content" of the command
    // nil for control commands and state requests
    // ConfigStruct for Config requests
    // String for error messages
    //TODO Clarify: String or Struct for data commands (containing trigger information)
    // Command of recordcontrol asserts the interface into the expected type for that command
    Data interface{}
    //TODO Include the use of the timestamp object
    // Feedback channel for the response of the client
    FeedbackChannel chan []byte
}

// Data representing the configuration as set by the user
type DataConfig struct {
    // Cameras to record from
    Camera_ids []int
    // Microphones to record from
    Microphone_ids []int
    // Location to record to
    Recording_location string
    // Id of the subject
    Subject_id string
}
